[
  {
    "objectID": "tutorials.html",
    "href": "tutorials.html",
    "title": "Tutorials",
    "section": "",
    "text": "Tutorials\nAll example scripts presented on this page can be found in the repository in the examples directory.\n\n\n\n\n\n\nSetup, Retrieval, Serialization\n\n\n\n\n\nimport germaparlpy.utilities as utilities\nfrom germaparlpy.corpus import *\n\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")\n\nif __name__ == \"__main__\":\n\n    # clone the germaparl corpus from github. We specify the parent directory as target since we are one level lower.\n    utilities.clone_corpus(directory=\"..\")\n\n    # we deserialize the XML corpus and specify the legislative periods as intervals. The interval range(16,20) in python\n    # comprises 16, 17, 18 and 19 because intervals in python are right-open. Integer representing singular legislative\n    # terms are also a valid argument.\n    corpus = Corpus.deserialize_from_xml(range(16,20), path=\"../GermaParlTEI\")\n\n    # Retrieval of all speeches from members affiliated with the party SPD:\n    partition_spd = corpus.get_speeches_from_party(party=\"SPD\")\n\n    # All speeches are enclosed within a sp element that is annotated with metadata in element attributes. Print all\n    # attributes to determine, what to search for.\n    # Output: ['who_original', 'party', 'parliamentary_group', 'who', 'name', 'position', 'role']\n    unique_element_attributes = utilities.extract_element_attributes(corpus, tag=\"sp\")\n    print(unique_element_attributes)\n\n    # After retrieving the attribute names, we can search the corpus for unique values for a certain attribute. Let's\n    # assume that you want to have a list of all annotated roles in the parliament.\n    # Output: ['mp', 'presidency', 'parliamentary_commissioner', 'misc', 'government']\n    unique_role_values = utilities.extract_attribute_values(corpus, tag=\"sp\", attribute=\"role\")\n    print(unique_role_values)\n\n    # Let's retrieve all speeches from all members of the cabinet in the corpus.\n    partition_chancellor = corpus.get_speeches_from_role(role=\"goverment\")\n\n    # Retrieval methods can be chained. Let's assume that you want to retrieve all speeches from members of the CDU, which\n    # are regular members of the parliament that contain the term \"Wirtschaft\" at least once. You can use the following\n    # method chain for this:\n    partition = (corpus.get_speeches_from_party(party=\"CDU\")\n               .get_speeches_from_role(role=\"mp\")\n               .get_speeches_from_keyword(keyword=\"Wirtschaft\"))\n\n    # You can get the actual content from the markup as a list of strings for further processing with toolkit methods:\n    all_paragraphs = utilities.get_paragraphs_from_corpus(partition)\n    all_interjections = utilities.get_interjections_from_corpus(partition)\n\n    # You can use the built-in methods len() and bool() on corpus or partition objects.\n    # Output: Our partition comprises 908 documents and 119462 paragraphs.\n    print(f\"Our partition comprises {len(partition)} documents and {len(all_paragraphs)} paragraphs.\")\n\n    # Partitions objects can be serialized as XML for human inspection, and Corpus and Partition instances can be\n    # serialized in JSON for intermediate storage.\n    partition.serialize_corpus_as_xml(path=\"../derived_corpus\")\n\n    # JSON serialization of a corpus object\n    corpus.serialize(path=\"backup.json\")\n\n    # Deserialize a corpus:\n    new_corpus = Corpus.deserialize_from_json(path=\"backup.json\")\n\n\n\n\n\n\n\n\n\nTTR Calculation\n\n\n\n\n\nimport matplotlib.pyplot as plt\nimport germaparlpy.utilities as utilities\nfrom germaparlpy.corpus import *\n\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")\n\nif __name__ == \"__main__\":\n\n    # Clone the GermaParl corpus from GitHub. We specify the parent directory as the target since we are one level below.\n    utilities.clone_corpus(directory=\"..\")\n\n    # We deserialize the XML corpus without specifying a legislative period. The default value is range(1, 20), which\n    # includes the entire corpus.\n    corpus = Corpus.deserialize_from_xml(path=\"../GermaParlTEI\")\n\n    # Let's assume we want to calculate the type-token ratio of all German chancellors. The type-token ratio is a\n    # simple statistical coefficient that quantifies the complexity of vocabulary.\n\n    # We implement the TTR calculation as a function.\n    def calculate_ttr(text: list[str]) -&gt; float:\n        text = [speech.split(\" \") for speech in text] # tokenize speeches\n        text = [token for speech in text for token in speech if token.isalnum()] # remove non-alphanumeric tokens from the speeches\n        return len(set(text)) / len(text) # return ttr\n\n    # We define all chancellors\n    chancellor_list = [\n        \"Konrad Adenauer\",\n        \"Ludwig Erhard\",\n        \"Kurt Georg Kiesinger\",\n        \"Willy Brandt\",\n        \"Helmut Schmidt\",\n        \"Helmut Kohl\",\n        \"Gerhard Schröder\",\n        \"Angela Merkel\"\n    ]\n\n    # We calculate the TTR for all chancellors and collect the results in a dictionary.\n    chancellor_ttr = {}\n\n    for chancellor in chancellor_list:\n        chancellor_parition = corpus.get_speeches_from_politician(person=chancellor)\n        chancellor_speeches = utilities.get_paragraphs_from_corpus(chancellor_parition)\n        chancellor_ttr[chancellor] = calculate_ttr(chancellor_speeches)\n\n    # Output:\n    # {'Konrad Adenauer': 0.06581790181141273, 'Ludwig Erhard': 0.07735575796964228,\n    # 'Kurt Georg Kiesinger': 0.07238602465784993, 'Willy Brandt': 0.05436169529177415,\n    # 'Helmut Schmidt': 0.04721755524197501, 'Gerhard Schröder': 0.0548574862993217,\n    # 'Angela Merkel': 0.04755084983588955}\n    print(chancellor_ttr)\n\n    # sort and visualize results\n    sorted_data = dict(sorted(chancellor_ttr.items(), key=lambda item: item[1], reverse=True))\n    plt.figure(figsize=(10, 6))\n    plt.bar(sorted_data.keys(), sorted_data.values(), color='skyblue')\n    plt.xlabel('Chancellor')\n    plt.ylabel('TTR')\n    plt.title('TTR of all german chancellors')\n    plt.xticks(rotation=45)\n    plt.show()\n\n\n\n\n\n\n\n\n\n\nSentiment Analysis of selected speeches\n\n\n\n\n\nimport germaparlpy.utilities as utilities\nfrom germaparlpy.corpus import *\nfrom germansentiment import SentimentModel\n\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")\n\nif __name__ == \"__main__\":\n\n    # We deserialize the corpus and specify the 19. legislative term.\n    corpus = Corpus.deserialize_from_xml(lp=19, path=\"../GermaParlTEI\")\n\n    # We load a BERT Model trained for german sentiment classification named \"german-sentiment-bert\" by guhr et al. (2020)\n    sentiment_model = SentimentModel()\n\n    # We retrieve all speeches from the party CDU that contain the keyword \"Asyl\" or the keywords \"Migration\"\n    corpus_cdu = corpus.get_speeches_from_party(\"CDU\").get_speeches_from_word_list([\"Asyl\", \"Migration\"])\n\n    # We retrieve all speeches from the party AfD that contain the keyword \"Asyl\" or the keywords \"Migration\"\n    corpus_afd = corpus.get_speeches_from_party(\"AfD\").get_speeches_from_word_list([\"Asyl\", \"Migration\"])\n\n    # We extract the text from the markup for further processing\n    corpus_cdu_paragraphs = utilities.get_paragraphs_from_corpus(corpus_cdu)\n    corpus_afd_paragraphs = utilities.get_paragraphs_from_corpus(corpus_afd)\n\n    # Output:\n    # The corpus partition containing the speeches of the cdu comprises 7560 paragraphs.\n    # The corpus partition containing the speeches of the cdu comprises 8218 paragraphs.\n    print(f\"The corpus partition containing the speeches of the cdu comprises {len(corpus_cdu_paragraphs)} paragraphs.\")\n    print(f\"The corpus partition containing the speeches of the cdu comprises {len(corpus_afd_paragraphs)} paragraphs.\")\n\n    # We implement the polarity calculation as a function since the library returns a string that we need to transform.\n    # We also have to break our data sets into chunks to cause no memory overflow since our partitions are quite big.\n\n    def calculate_polarity(p: list[str]) -&gt; float:\n        model = SentimentModel()\n        chunk_size = 100\n        chunks = [p[i:i + chunk_size] for i in range(0, len(p), chunk_size)]\n        total_polarity = 0\n\n        for chunk in chunks:\n            chunk_result = model.predict_sentiment(chunk)\n\n            for s in chunk_result:\n                if s == 'neutral':\n                    continue\n                elif s == 'negative':\n                    total_polarity -= 1\n                else:\n                    total_polarity += 1\n\n        return total_polarity / len(p)\n\n    # We calculate the polarity for both data sets.\n    corpus_cdu_polarity = calculate_polarity(corpus_cdu_paragraphs)\n    corpus_afd_polarity = calculate_polarity(corpus_afd_paragraphs)\n\n    # Output:\n    # The mean polarity of speeches in the 19. legislative period of the german parliament from the party CDU\n    # containing the word 'asyl' or 'migration' is -0.022389875882209784.\n    # The mean polarity of speeches in the 19. legislative period of the german parliament from the party AFD\n    # containing the word 'asyl' or 'migration' is -0.11084656084656085.\n\n    print(\"The mean polarity of speeches in the 19. legislative period of the german parliament from the party CDU \"\n          f\"containing the word 'asyl' or 'migration' is {corpus_cdu_polarity}.\")\n\n    print(\"The mean polarity of speeches in the 19. legislative period of the german parliament from the party AFD \"\n          f\"containing the word 'asyl' or 'migration' is {corpus_afd_polarity}.\")"
  },
  {
    "objectID": "documentation.html",
    "href": "documentation.html",
    "title": "Table of Contents",
    "section": "",
    "text": "Overview\nClass: Corpus\n\nConstructor\nStatic Methods\n\ndeserialize_from_json\ndeserialize_from_xml\n\nInstance Methods\n\nserialize\nget_corpus\nget_metadata\nget_partition_by_sp_attribute\nget_speeches_from_politician\nget_speeches_from_party\nget_speeches_from_role\n_get_speeches_from_condition\nget_speeches_from_keyword\nget_speeches_from_word_list\nget_speeches_from_regex\n\nMagic Methods\n\n__len__\n__bool__\n\nPrivate Methods\n\n__load_xml_for_legislative_period\n__extract_metadata\n__get_text\n\n\n\n\n\n\n\nOverview\nClass: Partition\n\nConstructor\nInstance Methods\n\nserialize_corpus_as_xml\n\nPrivate Methods\n\n__create_tei_header\n\n\n\n\n\n\n\nOverview\nModule: Utilities\n\nclone_corpus\nget_paragraphs_from_element\nget_interjections_from_element\nget_paragraphs_from_corpus\nget_interjections_from_corpus\nextract_element_attributes\nextract_attribute_values"
  },
  {
    "objectID": "documentation.html#api-reference-corpus",
    "href": "documentation.html#api-reference-corpus",
    "title": "Table of Contents",
    "section": "",
    "text": "Overview\nClass: Corpus\n\nConstructor\nStatic Methods\n\ndeserialize_from_json\ndeserialize_from_xml\n\nInstance Methods\n\nserialize\nget_corpus\nget_metadata\nget_partition_by_sp_attribute\nget_speeches_from_politician\nget_speeches_from_party\nget_speeches_from_role\n_get_speeches_from_condition\nget_speeches_from_keyword\nget_speeches_from_word_list\nget_speeches_from_regex\n\nMagic Methods\n\n__len__\n__bool__\n\nPrivate Methods\n\n__load_xml_for_legislative_period\n__extract_metadata\n__get_text"
  },
  {
    "objectID": "documentation.html#api-reference-partition",
    "href": "documentation.html#api-reference-partition",
    "title": "Table of Contents",
    "section": "",
    "text": "Overview\nClass: Partition\n\nConstructor\nInstance Methods\n\nserialize_corpus_as_xml\n\nPrivate Methods\n\n__create_tei_header"
  },
  {
    "objectID": "documentation.html#api-reference-utilities",
    "href": "documentation.html#api-reference-utilities",
    "title": "Table of Contents",
    "section": "",
    "text": "Overview\nModule: Utilities\n\nclone_corpus\nget_paragraphs_from_element\nget_interjections_from_element\nget_paragraphs_from_corpus\nget_interjections_from_corpus\nextract_element_attributes\nextract_attribute_values"
  },
  {
    "objectID": "documentation.html#overview",
    "href": "documentation.html#overview",
    "title": "Table of Contents",
    "section": "Overview",
    "text": "Overview\nThe Corpus class represents a collection of textual data, providing methods to manage, serialize, and query corpora. It allows loading corpora from JSON and XML formats, retrieving metadata, and filtering content based on different criteria."
  },
  {
    "objectID": "documentation.html#class-corpus",
    "href": "documentation.html#class-corpus",
    "title": "Table of Contents",
    "section": "Class: Corpus",
    "text": "Class: Corpus\n\nConstructor\nCorpus(name: str = \"\", corpus=None)\nInitializes a Corpus object.\nParameters:  name (optional): The name of the corpus.  corpus (optional): A dictionary representing the corpus structure. \n\n\n\nStatic Methods\n\ndeserialize_from_json\nstaticmethod deserialize_from_json(filepath: str, name: str) -&gt; Corpus\nFactory Method for creating Corpus objects from a JSON file. The JSON file should have been created by the object method serialize().\nParameters:  filepath : Path to the JSON file. name : Name of the corpus.\nReturns: The deserialized Corpus object.\n\n\n\ndeserialize_from_xml\nstaticmethod deserialize_from_xml(lp: Union[range, int], path: str, name: str) -&gt; Corpus\nFactory Method for creating Corpus objects from an XML corpus. The XML corpus should comply with the structure of the original GermaParlTEI Corpus that is fetched with utilities.clone_corpus() or created with Partition.serialize_corpus_as_xml().\nParameters: lp : Legislative term(s) as a range or integer. path (optional): Path to the corpus directory. name (optional): Name of the new corpus object.\nReturns: The deserialized Corpus object.\n\n\n\n\nInstance Methods\n\nserialize\nserialize(path: str) -&gt; None\nSerialize a Corpus object as JSON file.\nParameters: path: Path where the JSON file should be saved.\n\n\n\nget_corpus\nget_corpus(deep: bool = False) -&gt; dict[str, dict[str, Any]]\nReturns a copy of the instance’s corpus.\nParameters: deep (optional): If True, a deep copy is returned.\nReturns: A copy of the instance’s corpus.\n\n\n\nget_metadata\nget_metadata(key: str) -&gt; dict[str, str]\nRetrieves metadata for a specific corpus entry, representing a document.\nParameters: key: The corpus entry (#legislativePeriod_#sessionNumber).\nReturns: The metadata on the corpus entry, i.e., the document.\n\n\n\nget_partition_by_sp_attribute\nget_partition_by_sp_attribute(attribute: str, value: str) -&gt; Partition\nTemplate Method to filters the corpus based on an attribute of sp elements.\nAll div-elements and their matching child elements in the corpus are collected, if a children sp-element matches a specified attribute and value pair. The div-element containing the matched sp-element is collected, plus all child elements of sp. All sp-elements within the parent div-element that do not fulfill the condition, are not collected. All collected elements are assembled within a new ElementTree with a &lt;body&gt;-element as the root. The new corpus is indexed with the old key and the old metadata within a new Partition Object.\nParameters: attribute: The attribute name to filter by. value: The attribute value to match.\nReturns: A Partition object containing the matching elements.\n\n\n\nget_speeches_from_politician\nget_speeches_from_politician(person: str, attribute_name: str = \"name\") -&gt; Partition\nFilters speeches by politician name with get_partition_by_sp_attribute().\nParameters: person : The name of the politician. attribute_name (optional): Attribute name for the identification of the politician’s name.\nReturns: A Partition object containing speeches by the specified politician.\n\n\n\nget_speeches_from_party\nget_speeches_from_party(party: str) -&gt; Partition\nFilters speeches by party affiliation with get_partition_by_sp_attribute().\nParameters: party : The name of the party.\nReturns: A Partition object containing speeches from the specified party.\n\n\n\nget_speeches_from_role\nget_speeches_from_role(role: str, attribute_name: str = \"role\") -&gt; Partition\nFilters speeches by role with get_partition_by_sp_attribute().\nParameters: role : The role to filter by. attribute_name (optional): Attribute name for the role identification.\nReturns: Partition: A partition containing speeches from the specified role.\n\n\n\nget_speeches_from_condition\n_get_speeches_from_condition(condition: Callable[[str], bool]) -&gt; Partition\nTemplate Method to filters speeches based on a user-defined condition concerning the content.\nAll div-elements and their matching child elements in the corpus are collected, if a children sp-element fulfills the condition. The &lt;div&gt;-element containing the matched &lt;sp&gt;-element is collected, plus all child elements of sp. All &lt;sp&gt;-elements within the parent &lt;div&gt;-element that do not fulfill the condition, are not collected. All collected elements are assembled within a new ElementTree with a &lt;body&gt;-element as the root. The new corpus is indexed with the old key and the old metadata within a new Partition Object.\nParameters: condition : A function that takes a string (speech text) and returns a boolean.\nReturns: A Partition object containing speeches that match the condition.\n\n\n\nget_speeches_from_keyword\nget_speeches_from_keyword(keyword: str, case_sensitive: bool = False) -&gt; Partition\nFilters speeches containing a specified keyword with get_speeches_from_condition().\nParameters: keyword : The keyword to search for. case_sensitive (optional): Whether the search is case-sensitive.\nReturns: A Partition object containing speeches with the keyword.\n\n\n\nget_speeches_from_word_list\nget_speeches_from_word_list(word_list: list[str], case_sensitive: bool = False) -&gt; Partition\nFilters speeches containing any word from a given list.\nParameters: word_list : A list of words to search for. case_sensitive (optional): Whether the search is case-sensitive.\nReturns: A Partition Object containing speeches with any of the specified words.\n\n\n\nget_speeches_from_regex\nget_speeches_from_regex(pattern: str) -&gt; Partition\nFilters speeches using a regular expression with get_speeches_from_condition().\nParameters: pattern : Regular expression pattern to match.\nReturns: A Partition object containing speeches that match the pattern.\n\n\n\n\nMagic Methods\n\nlen\n__len__() -&gt; int\nReturns the number of entries in the corpus.\nReturns: Number of entries in the corpus.\n\n\n\nbool\n__bool__() -&gt; bool\nReturns whether the corpus is non-empty.\nReturns: True if the corpus contains entries, otherwise False.\n\n\n\n\nPrivate Methods for internal use\n\nload_xml_for_legislative_period\n__load_xml_for_legislative_period(lp: int, path: str) -&gt; None\nLoads XML files for a given legislative period.\n\n\nextract_metadata\nstaticmethod __extract_metadata(tree: ElementTree) -&gt; dict[str, str]\nExtracts metadata from an XML document.\n\n\nget_text\nstaticmethod __get_text(element: Element, path: str) -&gt; str\nExtracts text from an XML element."
  },
  {
    "objectID": "documentation.html#overview-1",
    "href": "documentation.html#overview-1",
    "title": "Table of Contents",
    "section": "Overview",
    "text": "Overview\nThe Partition class implements a partition of a corpus as objects. Objects of this class are created by the retrieval methods of the parent class Corpus."
  },
  {
    "objectID": "documentation.html#class-partition",
    "href": "documentation.html#class-partition",
    "title": "Table of Contents",
    "section": "Class: Partition",
    "text": "Class: Partition\n\nConstructor\nCorpus(name: str = \"\", corpus=None)\nInitializes a Partition object by calling the super class Corpus.\nParameters: corpus (optional): A dictionary representing the corpus structure.\n\n\n\nInstance Methods\n\nserialize_corpus_as_xml\nserialize_corpus_as_xml(self, path: str = \"derived_corpus\") -&gt; None:\nSerializes the corpus as a set of XML files. Generates an XML file for every entry in the corpus in a specified folder that is created during runtime under “path”.\nParameters: path (optional): The path and name of the folder to be created.\n\n\n\n\nPrivate Methods for internal use\n\ncreate_tei_header\nstaticmethod __create_tei_header(metadata: dict) -&gt; Element:\nCreates a &lt; teiHeader &gt; element from the given metadata dictionary.\nParameters: metadata: The metadata dictionary.\nReturns: The &lt; teiHeader &gt; element as an Element object."
  },
  {
    "objectID": "documentation.html#overview-2",
    "href": "documentation.html#overview-2",
    "title": "Table of Contents",
    "section": "Overview",
    "text": "Overview\nThe module Utilities provides a set of functions to retrieve data from Corpus objects and fetch the TEI-Corpus from GitHub. It includes utilities for extracting text and attributes from corpus elements."
  },
  {
    "objectID": "documentation.html#module-utilities",
    "href": "documentation.html#module-utilities",
    "title": "Table of Contents",
    "section": "Module: Utilities",
    "text": "Module: Utilities\n\nFunctions\n\nclone_corpus\nclone_corpus(repo_url: str = \"https://github.com/PolMine/GermaParlTEI.git\") -&gt; None\nClones the GermaParlTEI corpus from GitHub.\nParameters: repo_url (optional): The URL of the repository. Defaults to https://github.com/PolMine/GermaParlTEI.git.\n\n\n\nget_paragraphs_from_element\nget_paragraphs_from_element(element: Element) -&gt; list[str]\nExtracts the text content from all &lt;p&gt; elements that are descendants of the given XML element.\nParameters: element: The parent XML element.\nReturns: A list of text content from all &lt;p&gt; elements found in the subtree.\n\n\n\nget_interjections_from_element\nget_interjections_from_element(element: Element) -&gt; list[str]\nExtracts the text content from all &lt;stage&gt; elements that are descendants of the given XML element.\nParameters: element: The parent XML element.\nReturns: A list of text content from all &lt;stage&gt; elements found in the subtree.\n\n\n\nget_paragraphs_from_corpus\nget_paragraphs_from_corpus(corpus: Corpus) -&gt; list[str]\nExtracts the text content from all &lt;p&gt; elements, which contain speeches without interjections, from the given Corpus object.\nParameters: corpus: The Corpus object.\nReturns: A list of text content from all &lt;p&gt; elements in the corpus.\n\n\n\nget_interjections_from_corpus\nget_interjections_from_corpus(corpus: Corpus) -&gt; list[str]\nExtracts the text content from all &lt;stage&gt; elements, which contain interjections to speeches, from the given Corpus object.\nParameters: corpus: The Corpus object.\nReturns: A list of text content from all &lt;stage&gt; elements in the corpus.\n\n\n\nextract_element_attributes\nextract_element_attributes(corpus: Corpus, tag_name: str) -&gt; list[str]\nExtracts all unique attributes of a specified tag from all documents in the corpus.\nParameters: corpus: The Corpus object containing the documents. tag_name: The name of the tag whose attributes should be retrieved.\nReturns: A list of unique attributes found in the specified tag.\n\n\n\nextract_attribute_values\nextract_attribute_values(corpus: Corpus, tag: str, attribute: str) -&gt; list[str]\nExtracts the values of a specific attribute from the specified tag across all documents in the corpus.\nParameters: corpus: The Corpus object containing the documents. tag: The tag whose attributes should be searched. attribute: The name of the attribute whose values should be extracted.\nReturns: A list of unique values for the specified attribute."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GermaParlPy",
    "section": "",
    "text": "The GermaParlPy Python package provides functionality to deserialize, serialize, manage, and query the GermaParlTEI1 corpus and derived corpora.\nThe GermaParlTEI corpus comprises the plenary protocols of the German Bundestag (parliament), encoded in XML according to the TEI standard. The current version covers the first 19 legislative periods, encompassing transcribed speeches from the Bundestag’s constituent session on 7 September 1949 to the final sitting of the Angela Merkel era in 2021. This makes it a valuable resource for research in various scientific disciplines.\nThis website describes the installation, API reference, usage and further information about the GermaParlPy software library."
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "GermaParlPy",
    "section": "",
    "text": "The GermaParlPy Python package provides functionality to deserialize, serialize, manage, and query the GermaParlTEI1 corpus and derived corpora.\nThe GermaParlTEI corpus comprises the plenary protocols of the German Bundestag (parliament), encoded in XML according to the TEI standard. The current version covers the first 19 legislative periods, encompassing transcribed speeches from the Bundestag’s constituent session on 7 September 1949 to the final sitting of the Angela Merkel era in 2021. This makes it a valuable resource for research in various scientific disciplines.\nThis website describes the installation, API reference, usage and further information about the GermaParlPy software library."
  },
  {
    "objectID": "index.html#use-cases",
    "href": "index.html#use-cases",
    "title": "GermaParlPy",
    "section": "Use Cases",
    "text": "Use Cases\nPotential use cases range from the examination of research questions in political science, history or linguistics to the compilation of training data sets for AI.\nIn addition, this library makes it possible to access the GermaParl corpus in Python and apply powerful NLP libraries such as spacy or gensim to it. Previously, the corpus could only be accessed using the PolMineR package in the R programming language."
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "GermaParlPy",
    "section": "Installation",
    "text": "Installation\nGermaParlPy is available in PyPi:\npip install germaparlpy\nOr install from source:\ngit clone git@github.com:Nolram567/GermaParlPy.git\ncd germaparlpy\npip install ."
  },
  {
    "objectID": "index.html#api-reference",
    "href": "index.html#api-reference",
    "title": "GermaParlPy",
    "section": "API Reference",
    "text": "API Reference\nClick here for the full API Reference."
  },
  {
    "objectID": "index.html#xml-structure",
    "href": "index.html#xml-structure",
    "title": "GermaParlPy",
    "section": "XML Structure",
    "text": "XML Structure\nClick here to learn more about the XML Structure of the underlying corpus GermaParlTEI2."
  },
  {
    "objectID": "index.html#tutorials",
    "href": "index.html#tutorials",
    "title": "GermaParlPy",
    "section": "Tutorials",
    "text": "Tutorials\nI have prepared three example scripts that showcase the utilisation and potential use cases of GermaParlPy. You can find the scripts in the /example directory or here."
  },
  {
    "objectID": "index.html#contributing",
    "href": "index.html#contributing",
    "title": "GermaParlPy",
    "section": "Contributing",
    "text": "Contributing\nContributions and feedback are welcome! Feel free to write an issue or open a pull request."
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "GermaParlPy",
    "section": "License",
    "text": "License\nThe code is licensed under the MIT License.\nThe GermaParl corpus, which is not part of this repository, is licensed under a CLARIN PUB+BY+NC+SA license."
  },
  {
    "objectID": "index.html#credits",
    "href": "index.html#credits",
    "title": "GermaParlPy",
    "section": "Credits",
    "text": "Credits\nDeveloped by Marlon-Benedikt George.\nThe underlying data set, the GermaParl corpus, was compiled and released by Blätte & Leonhardt (2024)3. See also their R-Library PolMineR in the context of the PolMine-Project, which served as an inspiration for this library."
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "GermaParlPy",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nBlaette, A.and C. Leonhardt. Germaparl corpus of plenary protocols. v2.2.0-rc1, Zenodo, 22 July 2024, doi:10.5281/zenodo.12795193↩︎\nBlaette, A.and C. Leonhardt. Germaparl corpus of plenary protocols. v2.2.0-rc1, Zenodo, 22 July 2024, doi:10.5281/zenodo.12795193↩︎\nBlaette, A.and C. Leonhardt. Germaparl corpus of plenary protocols. v2.2.0-rc1, Zenodo, 22 July 2024, doi:10.5281/zenodo.12795193↩︎"
  },
  {
    "objectID": "xml-structure.html",
    "href": "xml-structure.html",
    "title": "XML Structure of GermaParlTEI",
    "section": "",
    "text": "The corpus of Blätte et al.1 on which this library is based follows the structure described here. Corpus partitions serialized in XML follow the same structure. To use the method Corpus.get_partition_by_sp_attribute or methods based on this method with non-standard parameters, familiarize yourself with the structure of the corpus.\nA blueprint is shown below. For more details, e.g., regarding the data types, take a look at the XSD further below."
  },
  {
    "objectID": "xml-structure.html#section",
    "href": "xml-structure.html#section",
    "title": "XML Structure of GermaParlTEI",
    "section": "",
    "text": "An automatically generated XSD:\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" elementFormDefault=\"qualified\"&gt;\n    &lt;xs:element name=\"TEI\"&gt;\n        &lt;xs:complexType&gt;\n            &lt;xs:sequence&gt;\n                &lt;xs:element ref=\"teiHeader\"/&gt;\n                &lt;xs:element ref=\"text\"/&gt;\n            &lt;/xs:sequence&gt;\n        &lt;/xs:complexType&gt;\n    &lt;/xs:element&gt;\n    &lt;xs:element name=\"teiHeader\"&gt;\n        &lt;xs:complexType&gt;\n            &lt;xs:sequence&gt;\n                &lt;xs:element ref=\"fileDesc\"/&gt;\n                &lt;xs:element ref=\"encodingDesc\"/&gt;\n                &lt;xs:element ref=\"profileDesc\"/&gt;\n                &lt;xs:element ref=\"revisionDesc\"/&gt;\n            &lt;/xs:sequence&gt;\n        &lt;/xs:complexType&gt;\n    &lt;/xs:element&gt;\n    &lt;xs:element name=\"fileDesc\"&gt;\n        &lt;xs:complexType&gt;\n            &lt;xs:sequence&gt;\n                &lt;xs:element ref=\"titleStmt\"/&gt;\n                &lt;xs:element ref=\"editionStmt\"/&gt;\n                &lt;xs:element ref=\"publicationStmt\"/&gt;\n                &lt;xs:element ref=\"sourceDesc\"/&gt;\n            &lt;/xs:sequence&gt;\n        &lt;/xs:complexType&gt;\n    &lt;/xs:element&gt;\n    &lt;xs:element name=\"titleStmt\"&gt;\n        &lt;xs:complexType&gt;\n            &lt;xs:sequence&gt;\n                &lt;xs:element ref=\"title\"/&gt;\n                &lt;xs:element ref=\"legislativePeriod\"/&gt;\n                &lt;xs:element ref=\"sessionNo\"/&gt;\n            &lt;/xs:sequence&gt;\n        &lt;/xs:complexType&gt;\n    &lt;/xs:element&gt;\n    &lt;xs:element name=\"title\" type=\"xs:string\"/&gt;\n    &lt;xs:element name=\"legislativePeriod\" type=\"xs:integer\"/&gt;\n    &lt;xs:element name=\"sessionNo\" type=\"xs:integer\"/&gt;\n    &lt;xs:element name=\"editionStmt\"&gt;\n        &lt;xs:complexType&gt;\n            &lt;xs:sequence&gt;\n                &lt;xs:element ref=\"edition\"/&gt;\n            &lt;/xs:sequence&gt;\n        &lt;/xs:complexType&gt;\n    &lt;/xs:element&gt;\n    &lt;xs:element name=\"edition\"&gt;\n        &lt;xs:complexType&gt;\n            &lt;xs:sequence&gt;\n                &lt;xs:element ref=\"package\"/&gt;\n                &lt;xs:element ref=\"version\"/&gt;\n                &lt;xs:element ref=\"birthday\"/&gt;\n            &lt;/xs:sequence&gt;\n        &lt;/xs:complexType&gt;\n    &lt;/xs:element&gt;\n    &lt;xs:element name=\"package\" type=\"xs:NCName\"/&gt;\n    &lt;xs:element name=\"version\" type=\"xs:NMTOKEN\"/&gt;\n    &lt;xs:element name=\"birthday\" type=\"xs:NMTOKEN\"/&gt;\n    &lt;xs:element name=\"publicationStmt\"&gt;\n        &lt;xs:complexType&gt;\n            &lt;xs:sequence&gt;\n                &lt;xs:element ref=\"publisher\"/&gt;\n                &lt;xs:element ref=\"date\"/&gt;\n                &lt;xs:element ref=\"page\"/&gt;\n            &lt;/xs:sequence&gt;\n        &lt;/xs:complexType&gt;\n    &lt;/xs:element&gt;\n    &lt;xs:element name=\"publisher\" type=\"xs:string\"/&gt;\n    &lt;xs:element name=\"page\"&gt;\n        &lt;xs:complexType/&gt;\n    &lt;/xs:element&gt;\n    &lt;xs:element name=\"sourceDesc\"&gt;\n        &lt;xs:complexType&gt;\n            &lt;xs:sequence&gt;\n                &lt;xs:element ref=\"filetype\"/&gt;\n                &lt;xs:element ref=\"url\"/&gt;\n                &lt;xs:element ref=\"date\"/&gt;\n            &lt;/xs:sequence&gt;\n        &lt;/xs:complexType&gt;\n    &lt;/xs:element&gt;\n    &lt;xs:element name=\"filetype\" type=\"xs:NCName\"/&gt;\n    &lt;xs:element name=\"url\" type=\"xs:anyURI\"/&gt;\n    &lt;xs:element name=\"encodingDesc\"&gt;\n        &lt;xs:complexType&gt;\n            &lt;xs:sequence&gt;\n                &lt;xs:element ref=\"projectDesc\"/&gt;\n                &lt;xs:element ref=\"samplingDecl\"/&gt;\n                &lt;xs:element ref=\"editorialDecl\"/&gt;\n            &lt;/xs:sequence&gt;\n        &lt;/xs:complexType&gt;\n    &lt;/xs:element&gt;\n    &lt;xs:element name=\"projectDesc\" type=\"xs:string\"/&gt;\n    &lt;xs:element name=\"samplingDecl\"&gt;\n        &lt;xs:complexType/&gt;\n    &lt;/xs:element&gt;\n    &lt;xs:element name=\"editorialDecl\"&gt;\n        &lt;xs:complexType/&gt;\n    &lt;/xs:element&gt;\n    &lt;xs:element name=\"profileDesc\"&gt;\n        &lt;xs:complexType/&gt;\n    &lt;/xs:element&gt;\n    &lt;xs:element name=\"revisionDesc\"&gt;\n        &lt;xs:complexType/&gt;\n    &lt;/xs:element&gt;\n    &lt;xs:element name=\"text\"&gt;\n        &lt;xs:complexType&gt;\n            &lt;xs:sequence&gt;\n                &lt;xs:element ref=\"body\"/&gt;\n            &lt;/xs:sequence&gt;\n        &lt;/xs:complexType&gt;\n    &lt;/xs:element&gt;\n    &lt;xs:element name=\"body\"&gt;\n        &lt;xs:complexType&gt;\n            &lt;xs:sequence&gt;\n                &lt;xs:element maxOccurs=\"unbounded\" ref=\"div\"/&gt;\n            &lt;/xs:sequence&gt;\n        &lt;/xs:complexType&gt;\n    &lt;/xs:element&gt;\n    &lt;xs:element name=\"div\"&gt;\n        &lt;xs:complexType&gt;\n            &lt;xs:sequence&gt;\n                &lt;xs:element maxOccurs=\"unbounded\" ref=\"sp\"/&gt;\n            &lt;/xs:sequence&gt;\n            &lt;xs:attribute name=\"desc\" use=\"required\"/&gt;\n            &lt;xs:attribute name=\"n\" use=\"required\" type=\"xs:NMTOKEN\"/&gt;\n            &lt;xs:attribute name=\"type\" use=\"required\" type=\"xs:NCName\"/&gt;\n            &lt;xs:attribute name=\"what\" use=\"required\" type=\"xs:NCName\"/&gt;\n        &lt;/xs:complexType&gt;\n    &lt;/xs:element&gt;\n    &lt;xs:element name=\"sp\"&gt;\n        &lt;xs:complexType&gt;\n            &lt;xs:sequence&gt;\n                &lt;xs:element ref=\"speaker\"/&gt;\n                &lt;xs:choice maxOccurs=\"unbounded\"&gt;\n                    &lt;xs:element ref=\"p\"/&gt;\n                    &lt;xs:element ref=\"stage\"/&gt;\n                &lt;/xs:choice&gt;\n            &lt;/xs:sequence&gt;\n            &lt;xs:attribute name=\"name\" use=\"required\"/&gt;\n            &lt;xs:attribute name=\"parliamentary_group\" use=\"required\"/&gt;\n            &lt;xs:attribute name=\"party\" use=\"required\"/&gt;\n            &lt;xs:attribute name=\"role\" use=\"required\" type=\"xs:NCName\"/&gt;\n            &lt;xs:attribute name=\"who\" use=\"required\"/&gt;\n        &lt;/xs:complexType&gt;\n    &lt;/xs:element&gt;\n    &lt;xs:element name=\"speaker\" type=\"xs:string\"/&gt;\n    &lt;xs:element name=\"p\" type=\"xs:string\"/&gt;\n    &lt;xs:element name=\"stage\"&gt;\n        &lt;xs:complexType mixed=\"true\"&gt;\n            &lt;xs:attribute name=\"type\" use=\"required\" type=\"xs:NCName\"/&gt;\n        &lt;/xs:complexType&gt;\n    &lt;/xs:element&gt;\n    &lt;xs:element name=\"date\"&gt;\n        &lt;xs:complexType&gt;\n            &lt;xs:simpleContent&gt;\n                &lt;xs:extension base=\"xs:NMTOKEN\"&gt;\n                    &lt;xs:attribute name=\"when\"/&gt;\n                &lt;/xs:extension&gt;\n            &lt;/xs:simpleContent&gt;\n        &lt;/xs:complexType&gt;\n    &lt;/xs:element&gt;\n&lt;/xs:schema&gt;"
  },
  {
    "objectID": "xml-structure.html#footnotes",
    "href": "xml-structure.html#footnotes",
    "title": "XML Structure of GermaParlTEI",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nBlaette, A.and C. Leonhardt. Germaparl corpus of plenary protocols. v2.2.0-rc1, Zenodo, 22 July 2024, doi:10.5281/zenodo.12795193↩︎"
  }
]